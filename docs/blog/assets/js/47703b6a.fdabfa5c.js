"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[297],{4198:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"shift-left-vision","metadata":{"permalink":"/DocumentFilters/blog/shift-left-vision","source":"@site/blog/2024-09-26-shift-left-vision/index.md","title":"Shifting Left with Document Filters \u2013 A Vision for the Future","description":"Learn how Hyland Document Filters is \'shifting left\' to streamline document processing\u2014reducing complexity, improving efficiency, and accelerating AI/ML integration with cleaner, ready-to-use data.","date":"2024-09-26T00:00:00.000Z","tags":[{"label":"Roadmap","permalink":"/DocumentFilters/blog/tags/roadmap"},{"label":"AI","permalink":"/DocumentFilters/blog/tags/ai"}],"readingTime":5.59,"hasTruncateMarker":false,"authors":[{"name":"Nabih Metri","title":"Document Filters Product Owner","imageURL":"https://github.com/nmetrihyland.png","key":"nabihmetri"}],"frontMatter":{"slug":"shift-left-vision","title":"Shifting Left with Document Filters \u2013 A Vision for the Future","tags":["Roadmap","AI"],"authors":["nabihmetri"],"image":"./Thumbnail.png","description":"Learn how Hyland Document Filters is \'shifting left\' to streamline document processing\u2014reducing complexity, improving efficiency, and accelerating AI/ML integration with cleaner, ready-to-use data.","keywords":["AI","Blog","Computational efficiency","Content Enrichment","Data readiness","Document conversion","Document filters","Document preparation","Document transformation","Efficiency enhancement","ML","Performance improvement","Shift left","Streamlined workflows","Text extraction","Workflow automation","Workflow optimization"]},"unlisted":false,"nextItem":{"title":"Document Filters 24.3 Release","permalink":"/DocumentFilters/blog/24.3-release"}},"content":"As the digital landscape continues to evolve, the need for efficient document processing has never been greater. Applications demand accurate, structured data that\'s ready for immediate use, reducing the steps required to prepare it. At Hyland, we\'ve embraced this challenge with our Document Filters product. Our strategy? Shift left.\\n\\n## What Does It Mean to Shift Left?\\n\\nShifting left means moving essential tasks, such as data extraction, content enrichment, and quality control, to the start of the document processing workflow. For Document Filters, this translates into advanced capabilities that deliver output in a format instantly usable by downstream applications. By addressing complexity earlier, the entire process becomes streamlined, ensuring content is cleaner and more structured from the beginning.\\n\\nHistorically, document processing involved numerous stages\u2014starting with raw data extraction, followed by rounds of post-processing to clean, enrich, and structure content. Each phase added time, complexity, and sometimes manual intervention. Shifting left disrupts this model by embedding intelligence into the initial extraction phase, so the output is refined and structured right from the start.\\n\\nThis approach significantly reduces the steps needed to prepare data for use, allowing systems to handle documents more efficiently. Whether dealing with structured data, clean text, or processed images, the output is ready to integrate into applications or workflows, minimizing the need for further refinement. By prioritizing data readiness at the earliest stage, shifting left ensures faster, higher-quality outcomes.\\n\\n## The Benefits of Shifting Left\\n\\n### 1. Reducing Complexity and Streamlining Workflows\\n\\nBy enriching content earlier in the pipeline, downstream applications face fewer steps to manage. The result is cleaner, structured output requiring little to no further refinement, cutting down the time spent on data preparation. Shifting left with Document Filters simplifies the entire workflow.\\n\\nThis streamlined process improves operational efficiency by eliminating redundant steps and reducing the need for manual corrections. The cleaner the data, the fewer post-processing tasks are required, helping applications run more smoothly and deliver faster results.\\n\\n### 2. Improving Computational Efficiency\\n\\nDelivering high-quality, ready-to-use output early on means less processing power is needed to prepare data. Applications no longer need to rerun processes to clean or format data, conserving valuable resources.\\n\\nThis approach is particularly beneficial when managing large datasets or complex documents, where computational overhead can become a bottleneck. Complex documents, such as contracts or technical manuals, often demand extensive computational power. Shifting left tackles this by producing cleaner data early, reducing the workload for downstream systems.\\n\\nBy minimizing the extra steps required to get data ready for use, organizations can process documents more efficiently and at a lower cost. This not only reduces the time spent on each document but also allows systems to scale without significant increases in computing power or storage.\\n\\n### 3. Accelerating Data Processing\\n\\nBy shifting left, Document Filters produces output ready for immediate integration, cutting down the time it takes for data to move from extraction to application. As [McKinsey](https://www.mckinsey.com/capabilities/mckinsey-digital/our-insights/the-data-dividend-fueling-generative-ai) highlights, \u201cMost data will need to be prepped\u2014for example, by converting file formats and cleansing for data quality\u2026To speed up performance, [Chief Data Officers] need to standardize the handling of structured and unstructured data at scale.\u201d By delivering high-quality data from the start, applications can run faster and more efficiently.\\n\\nThis increased speed translates into quicker decision-making and reduced time-to-value. With fewer data preparation steps, content is available when and where it\'s needed, minimizing delays from manual adjustments or processing errors.\\n\\n### 4. Scaling with Ease\\n\\nAs businesses grow, their document processing needs become more complex. Shifting left allows Document Filters to handle increased workloads without adding complexity. Cleaner, more structured data from the outset makes it easier to manage large volumes without extra processing power or manual intervention.\\n\\nScaling often introduces bottlenecks, especially with new workflows or applications. By shifting left, Document Filters simplifies scaling by streamlining core data processing. This ensures that as document volumes grow\u2014whether through mergers, acquisitions, or organic growth\u2014the underlying infrastructure remains efficient and scalable.\\n\\nThis scalability enables businesses to process more documents and expand services without overhauling document processing workflows.\\n\\n### 5. Improving Integration with AI and Machine Learning Systems\\n\\nShifting left offers significant advantages when integrating document processing with AI and machine learning (ML) systems. By structuring, enriching, and cleansing files earlier in the workflow, it improves the accuracy of insights and predictions for AI/ML applications immediately, without the need for further preprocessing.\\n\\nAs [Gartner](https://www.gartner.com/en/articles/highlights-from-gartner-data-analytics-summit-2024) notes, \u201cThrough 2025, at least 30% of GenAI projects will be abandoned after proof of concept due to poor data quality, inadequate risk controls, escalating costs, or unclear business value.\u201d High-quality data is essential for the success of AI initiatives. If foundational data isn\'t clean and structured, even the most advanced AI technologies risk failing to deliver.\\n\\n[McKinsey](https://www.mckinsey.com/capabilities/mckinsey-digital/our-insights/the-data-dividend-fueling-generative-ai) emphasizes that \u201cIf your data isn\u2019t ready for generative AI, your business isn\u2019t ready for generative AI.\u201d It\u2019s not just about having the right tools\u2014it\u2019s about having the right data. Shifting left ensures that data is enriched before reaching AI systems, improving data quality and enhancing AI performance.\\n\\nBy delivering structured and clean data early, organizations can fully leverage AI capabilities, reducing computational costs and enabling faster, more accurate outcomes. With less need for preprocessing, businesses can apply machine learning models to refined datasets sooner, driving actionable insights at a lower cost.\\n\\n## Advancing Document Processing\\n\\nShifting left is not merely a tactical improvement\u2014it\u2019s a strategic vision for the future of document processing. As Document Filters evolves, our focus remains on delivering solutions that enhance workflows and boost application performance from the outset.\\n\\nDocument Filters is built to anticipate the changing needs of modern document workflows. As organizations increasingly rely on data-driven insights, the demand for clean, structured data will only grow. Our development efforts focus on providing tools that not only address current needs but also offer flexibility and scalability for future challenges.\\n\\nBy streamlining data preparation and reducing unnecessary steps, Document Filters positions applications to process documents more effectively. This forward-thinking approach ensures that content is not just extracted but immediately usable, enabling faster, more efficient workflows.\\n\\n## A Vision for the Future\\n\\nAt its core, shifting left is about reducing friction in document processing. By moving key tasks earlier in the pipeline, we enable more efficient workflows, reduce computational costs, and allow businesses to scale seamlessly. As Document Filters evolves, we remain committed to this vision\u2014ensuring applications can work with data that\u2019s ready to use, right from the start.\\n\\nThis is just the beginning. Shifting left is delivering tangible benefits\u2014helping organizations optimize workflows, reduce time-to-value, and unlock new levels of operational efficiency.\\n\\n## Document Filters Resources\\n\\n- [Document Filters on GitHub](https://github.com/Hyland/DocumentFilters)\\n- [Document Filters on NuGet](https://www.nuget.org/packages/Hyland.DocumentFilters)\\n- [Document Filters Samples](https://github.com/Hyland/DocumentFilters/tree/master/samples)\\n- [Document Filters Documentation](https://docs.hyland.com/DocumentFilters/en_US/Print/index.html)\\n- [Document Filters Release Notes](https://docs.hyland.com/DocumentFilters/en_US/Print/release_notes/index.html)\\n- [Hyland](https://www.hyland.com/en/products/document-filters)"},{"id":"24.3-release","metadata":{"permalink":"/DocumentFilters/blog/24.3-release","source":"@site/blog/2024-08-21-24.3-release/index.md","title":"Document Filters 24.3 Release","description":"Explore the new features of Hyland Document Filters with the 24.3 release, ranging from table detection to a markdown output type.","date":"2024-08-21T00:00:00.000Z","tags":[{"label":"Release","permalink":"/DocumentFilters/blog/tags/release"}],"readingTime":3.17,"hasTruncateMarker":true,"authors":[{"name":"Nabih Metri","title":"Document Filters Product Owner","imageURL":"https://github.com/nmetrihyland.png","key":"nabihmetri"}],"frontMatter":{"slug":"24.3-release","title":"Document Filters 24.3 Release","tags":["Release"],"authors":["nabihmetri"],"image":"./Thumbnail.png","description":"Explore the new features of Hyland Document Filters with the 24.3 release, ranging from table detection to a markdown output type.","keywords":["text extraction","document conversion","document transformation","document filters","text extraction","document conversion","document transformation","blog","demo","walk through","release","table detection","json","markdown","msi","hwpx","AI","ML"]},"unlisted":false,"prevItem":{"title":"Shifting Left with Document Filters \u2013 A Vision for the Future","permalink":"/DocumentFilters/blog/shift-left-vision"},"nextItem":{"title":"Exploring the Document Comparison APIs","permalink":"/DocumentFilters/blog/comparison-api"}},"content":"import JSON from \'./JSON.gif\'\\nimport Markdown_ChatGPT from \'./Markdown_ChatGPT.gif\'\\nimport GifPlayer from \'@site/src/components/GifPlayer\';\\nimport YouTubePlayer from \'@site/src/components/YouTubePlayer\';\\nimport ImgViewer from \'@site/src/components/ImgViewer\';\\n\\n\\nWe\'re excited to announce the latest release of Document Filters, packed with powerful new features designed to enhance your document processing capabilities. This update introduces a JSON Output Type for structured data handling, a Markdown Output Type for streamlined document conversion, advanced PDF Table Extraction for improved data accuracy, and MSI Installer Sub-File Extraction for comprehensive file analysis. Additionally, we\'ve added community-inspired support for Hancom Hangul HWPX text extraction and HD rendering. Read on to discover how these new features can elevate your workflows and drive better results.\\n\\n\x3c!-- truncate --\x3e\\n\\nWatch as we walk through a few of the new features in the 24.3 release of Document Filters.\\n\\n<YouTubePlayer src=\\"https://www.youtube.com/embed/Iou3fnOuTSo?si=zSEciPzwpaO4nEBA\\" alt=\\"Hyland Document Filters - 24.3 Features Preview Video\\" />\\n\\n## PDF Table Extraction\\n\\nDocument Filters now supports the identification and extraction of tables from untagged PDF files. This feature preserves the logical structure of tables, rows, and cells, ensuring accurate table detection for PDFs. Preserving the structures of tables allows AI/ML systems to improve their data quality and accuracy when processing documents.\\n\\n<ImgViewer src={require(\'./PDF_TABLE_DETECTION.png\').default} alt=\\"Hyland Document Filters - PDF Table Extraction\\" />\\n\\nDetecting and extracting the table information from an invoice. The image on the left displays how information is extracted with table detection disabled, while the right displays how information is extrated with table detection enabled.\\n\\n## JSON Output Type\\n\\nDocument Filters now includes support for a JSON output type, which structures document data in a detailed, hierarchical format. This enhancement facilitates seamless integration with AI and other JSON-compatible applications, ensuring efficient parsing and utilization of document content for improved AI/ML-driven data analysis and processing.\\n\\n<GifPlayer src={JSON} alt=\\"Hyland Document Filters - JSON Output Type\\" />\\n\\nConverting an invoice with a table into JSON, and keeping its table structure.\\n\\n## Markdown Output Type\\n\\nConverting documents to a Markdown output type is now supported. This feature allows users to effortlessly convert documents to Markdown, providing a lightweight and efficient way to present formatted content. It is ideal for use with AI/ML systems, as the lightweight and structured composition of Markdown reduces computing costs, as well as enhances data processing.\\n\\n<ImgViewer src={require(\'./Markdown.png\').default} alt=\\"Hyland Document Filters - Markdown Output Type\\" />\\n\\nConverting an invoice with a table into Markdown, and keeping its table structure.\\n\\n### Markdown AI Use Case\\n\\n<GifPlayer src={Markdown_ChatGPT} alt=\\"Hyland Document Filters - Markdown AI Use Case\\" />\\n\\nHere we passed in the Markdown generated from the invoice into ChatGPT and gave it the prompt of \\"Complete this invoice and display it in a readable format.\\" ChatGPT was able to correctly identify and understand the context of the table and fill in the missing values. Using Markdown with table detection allowed ChatGPT to have better context compared to plain text, as well as need less resources compared to full JSON, HTML, or XML.\\n\\n## MSI Installer Sub-File Extraction\\n\\nOur latest update introduces support for sub-file extraction from MSI installer files. This addition enables better handling and analysis of MSI files by extracting embedded files for further processing, enhancing the overall file analysis workflow in security systems.\\n\\n## Hancom Hangul HWPX Text and HD Support (Community-Inspired)\\n\\nIn response to community feedback, we have introduced text extraction and HD rendering support for Hancom Hangul HWPX files. This update enhances the ability to process and utilize content from these files, as well as ensures enhanced rendering fidelity of complex Korean language documents, maintaining their original formatting and layout.\\n\\n## Release Links\\n\\n- [Document Filters 24.3 Release Notes](https://docs.hyland.com/DocumentFilters/en_US/Print/release_notes/rel_24_3_0_0000.html)\\n- [Document Filters 24.3 Software Bill of Materials](https://github.com/Hyland/DocumentFilters/releases/download/v24.3.0/document-filters-24.3.0.5160-sbom.json)\\n- [Enhancement Requests](https://community.hyland.com/feedback)\\n\\n## Document Filters Resources\\n\\n- [Document Filters on GitHub](https://github.com/Hyland/DocumentFilters)\\n- [Document Filters on NuGet](https://www.nuget.org/packages/Hyland.DocumentFilters)\\n- [Document Filters Samples](https://github.com/Hyland/DocumentFilters/tree/master/samples)\\n- [Document Filters Documentation](https://docs.hyland.com/DocumentFilters/en_US/Print/index.html)\\n- [Document Filters Release Notes](https://docs.hyland.com/DocumentFilters/en_US/Print/release_notes/index.html)\\n- [Hyland](https://www.hyland.com/en/products/document-filters)"},{"id":"comparison-api","metadata":{"permalink":"/DocumentFilters/blog/comparison-api","source":"@site/blog/2024-05-29-comparison-api/index.md","title":"Exploring the Document Comparison APIs","description":"Hyland Document Filters 24.2 introduces powerful Document Comparison APIs, enabling developers to implement robust document comparison capabilities. Enhance your applications by identifying and managing changes across various document types with this significant update.","date":"2024-05-29T00:00:00.000Z","tags":[{"label":"Feature","permalink":"/DocumentFilters/blog/tags/feature"},{"label":"API","permalink":"/DocumentFilters/blog/tags/api"}],"readingTime":6.67,"hasTruncateMarker":true,"authors":[{"name":"Ben Truscott","title":"Document Filters Principal Engineer","imageURL":"https://github.com/bentruscott.png","key":"bentruscott"}],"frontMatter":{"slug":"comparison-api","title":"Exploring the Document Comparison APIs","tags":["Feature","API"],"authors":["bentruscott"],"image":"./Thumbnail.png","description":"Hyland Document Filters 24.2 introduces powerful Document Comparison APIs, enabling developers to implement robust document comparison capabilities. Enhance your applications by identifying and managing changes across various document types with this significant update."},"unlisted":false,"prevItem":{"title":"Document Filters 24.3 Release","permalink":"/DocumentFilters/blog/24.3-release"},"nextItem":{"title":"Document Filters 24.2 Release","permalink":"/DocumentFilters/blog/24.2-release"}},"content":"import ImgViewer from \'@site/src/components/ImgViewer\';\\n\\n\\nThe release of [Hyland Document Filters 24.2](../2024-05-15-24.2-release/index.md)\\nmarks a significant milestone with the introduction of powerful Document\\nComparison APIs. These new features are designed to enhance the ability of\\ndevelopers to implement robust document comparison capabilities within their\\napplications, facilitating the identification and management of changes across\\nvarious document types.\\n\\n\x3c!-- truncate --\x3e\\n\\n## Key Features of the Document Comparison APIs\\n\\nThe Document Comparison APIs in Hyland Document Filters 24.2 offer several\\nadvanced features that cater to the diverse needs of document management and\\nprocessing. Here are the highlights:\\n\\n### Text Content Comparison\\n\\nThe APIs enable precise comparison of text content between two documents. This\\nfeature supports word-level granularity, allowing users to detect and highlight\\ninsertions, deletions, and modifications with accuracy. Whether you\'re comparing\\ncontract versions or tracking changes in a collaborative document, this\\nfunctionality ensures that no alteration goes unnoticed.\\n\\n### Reading Order Analysis\\n\\nMaintaining the logical flow of content is crucial in document comparison. The\\nAPIs analyze the reading order to ensure that the comparison respects the\\nintended sequence of information. This is particularly useful for complex\\ndocuments like reports and academic papers where the order of content\\nsignificantly impacts comprehension.\\n\\n### Independence from File Types\\n\\nOne of the standout features of these APIs is their ability to compare documents\\nregardless of their file types. Hyland Document Filters support a wide range of\\nformats, including DOCX, PDF, HTML, and more. This flexibility means you can\\ncompare a Word document with a PDF file seamlessly, making it easier to manage\\ndiverse document types within your workflow.\\n\\n### Formatting and Pagination Considerations\\n\\nThe APIs are equipped to handle differences in formatting and pagination. Users\\ncan choose to include or exclude headers, footers, and fields in the comparison,\\nproviding control over which elements are considered. This level of\\ncustomization ensures that the comparison results are tailored to your specific\\nneeds, whether you\'re focusing on content changes or layout adjustments.\\n\\n## Benefits of Using Hyland Document Filters for Document Comparison\\n\\n### Accuracy and Reliability\\n\\nHyland Document Filters are renowned for their precision and reliability. The\\nDocument Comparison APIs leverage this robust foundation to deliver accurate\\ncomparison results, ensuring that even the smallest changes are detected and\\nreported.\\n\\n### Scalability\\n\\nWhether you\'re comparing a handful of documents or processing thousands daily,\\nthe APIs are designed to scale with your needs. Their performance and efficiency\\nmake them suitable for enterprise-level applications.\\n\\n### Integration Flexibility\\n\\nThe APIs are designed to be easily integrated into various applications, whether\\ndesktop, web, or mobile. This flexibility allows you to incorporate document\\ncomparison capabilities into your existing workflows with minimal disruption.\\n\\n## Implementing Document Comparison\\n\\n:::info\\n\\nA complete example of comparing documents can be found on GitHub for\\n[C#](https://github.com/Hyland/DocumentFilters/tree/master/samples/csharp/CompareDocuments)\\nand\\n[Python](https://github.com/Hyland/DocumentFilters/blob/master/samples/python/CompareDocuments.py).\\n\\n:::\\n\\nIntegrating the Document Comparison APIs into your application is\\nstraightforward. Here\'s a high-level overview of how you can get started:\\n\\n1. **Initialize the API**: Begin by setting up the Document Filters environment\\n   and initializing the Document Comparison API.\\n\\n```csharp title=\\"C#\\" showLineNumbers\\nHyland.DocumentFilters.Api api = new Hyland.DocumentFilters.Api();\\napi.Initialize(\\"License Code\\", \\".\\")\\n```\\n\\n2. **Load the Documents**: Load the documents you wish to compare. The API\\n   supports various input formats, making it easy to work with different\\n   document types.\\n\\n```csharp title=\\"C#\\" showLineNumbers\\nExtractor doc1 = api.OpenExtractor(\\"path/to/document1.docx\\", OpenMode.Paginated);\\nExtractor doc2 = api.OpenExtractor(\\"path/to/document2.pdf\\", OpenMode.Paginated);\\n```\\n\\n3. **Perform the Comparison**: Execute the comparison operation and retrieve the\\n   results. The API provides detailed output, highlighting the differences\\n   between the documents.\\n\\n```csharp title=\\"C#\\" showLineNumbers\\nusing (var compare = doc1.Compare(doc2)) {\\n   // Work with compare results\\n}\\n```\\n\\n4. **Process the Results**: Utilize the comparison results within your\\n   application. You can display the differences, generate reports, or trigger\\n   further processing based on the detected changes.\\n\\n```csharp title=\\"C#\\" showLineNumbers\\nwhile (compare.MoveNext())\\n{\\n    var diff = compare.Current;\\n    // Work with diff...\\n}\\n```\\n\\nAs you enumerate over the items in a compare result, the diffs will be one of\\nthe following types:\\n\\n- **Equals** - These diff items are not included by default but can be enabled\\n  with a flag.\\n- **Insert** - Text exists in the new/revised document but not in the\\n  old/original document.\\n- **Delete** - Text exists in the old/original document but not in the\\n  new/revised document.\\n\\nUsing this information, we can create side-by-side comparison views that show\\nthe edits to both the original and revised documents.\\n\\n<ImgViewer src={require(\'./CompareMarkup.png\').default} alt=\\"Hyland Document Filters - Document Comparison Markup\\" />\\n\\n\\nTo produce the marked-up version, we can use the Document Filter\'s [Canvas\\nobject](https://docs.hyland.com/DocumentFilters/en_US/Print/object_reference/canvas_interface.html).\\n\\nWhile enumerating the diffs, you may encounter situations where some pages do\\nnot have differences. Additionally, as content is added or removed, the page\\nindexes of the original and revised documents can get out of sync.\\n\\nHandling scenarios where pages do not have differences or where page indexes get\\nout of sync due to content changes requires a careful approach. Here\u2019s how we\\ncan manage this:\\n\\n1. **Create Two Output Canvases**: One for the original document and one for the\\n   revised document.\\n2. **Track the Current Page**: Maintain a record of the current page being\\n   processed.\\n3. **Ensure Page Rendering**: As we enumerate the diffs, ensure that all pages\\n   up to the \\"current page\\" have been rendered.\\n4. **Mark Up Diffs**: Proceed to mark up the differences on the current page\\n   once rendering is confirmed.\\n\\nThis method ensures that the comparison view remains accurate and consistent,\\nregardless of the number of differences or content shifts between the original\\nand revised documents.\\n\\n```csharp title=\\"C#\\" showLineNumbers\\nprivate void ensurePage(int pageIndex, Extractor doc, Canvas canvas, ref int currentPage, bool isLeft)\\n{\\n   while (currentPage < pageIndex)\\n   {\\n      using var page = doc.GetPage(++currentPage);\\n      canvas.RenderPage(page);\\n   }\\n   canvas.SetBrush(isLeft ? 0x50ff0000 : 0x5000ff00, 1);\\n   canvas.SetPen(0, 0, 0);\\n}\\n```\\n\\nThe ensurePage function takes the pageIndex of the page being rendered, the\\nExtractor containing either the original or revised document, the destination\\nCanvas, the page index of the last page rendered (i.e., the current page on the\\ncanvas), and a boolean indicating whether the document is the left document\\n(i.e., the original).\\n\\nThe function renders all pages up to pageIndex and then sets the brush to be\\neither red or green with slight transparency, depending on whether the document\\nis the original.\\n\\n```csharp title=\\"C#\\" showLineNumbers\\nusing Canvas leftOutputCanvas = api.MakeOutputCanvas(LeftOutput, CanvasType.PDF);\\nusing Canvas rightOutputCanvas = _api.MakeOutputCanvas(RightOutput, CanvasType.PDF);\\n\\nint currentLeft = -1, currentRight = -1;\\nwhile (compareResult.MoveNext())\\n{\\n   if (compareResult.Current.Type == DifferenceType.Equal || compareResult.Current.Type == DifferenceType.NextBatch)\\n      continue;\\n\\n   foreach (var hit in compareResult.Current.Details)\\n   {\\n      if (compareResult.Current.Type == DifferenceType.Delete)\\n      {\\n         ensurePage(hit.PageIndex, left, leftOutputCanvas, ref currentLeft, true);\\n         leftOutputCanvas.Rect(FromRectF(hit.Bounds));\\n      }\\n\\n      if (compareResult.Current.Type == DifferenceType.Insert)\\n      {\\n         ensurePage(hit.PageIndex, right, rightOutputCanvas, ref currentRight, false);\\n         rightOutputCanvas.Rect(FromRectF(hit.Bounds));\\n      }\\n   }\\n}\\nensurePage(left.PageCount, left, leftOutputCanvas, currentLeft, true);\\nensurePage(right.PageCount, right, rightOutputCanvas, currentRight, true);\\n```\\n\\nUpon completion, you will have two PDFs. The `LeftOutput` will contain every\\npage from the original document, marked up with text that does not exist in the\\nrevised document. Similarly, the `RightOutput` will contain every page from the\\nrevised document, marked up with text that does not exist in the original\\ndocument.\\n\\nIf you are building a viewing component, you may also want to keep track of the\\n`hit.PageIndex` properties to provide page synchronization as the user navigates\\nbetween the differences.\\n\\n:::info\\n\\nA complete example of comparing documents can be found on GitHub for\\n[C#](https://github.com/Hyland/DocumentFilters/tree/master/samples/csharp/CompareDocuments)\\nand\\n[Python](https://github.com/Hyland/DocumentFilters/blob/master/samples/python/CompareDocuments.py).\\n\\n:::\\n\\n## Conclusion\\n\\nThe introduction of Document Comparison APIs in Hyland Document Filters 24.2 is\\na game-changer for developers and organizations looking to streamline their\\ndocument management processes. With features like text content comparison,\\nreading order analysis, and independence from file types, these APIs offer a\\ncomprehensive solution for detecting and managing document changes. By\\nintegrating these powerful tools into your applications, you can enhance your\\ndocument comparison capabilities and ensure the integrity and accuracy of your\\ndocument workflows.\\n\\n## Document Filters Evaluation\\n\\n- [Try a feature limited version of Document Filters](https://github.com/Hyland/DocumentFilters/blob/master/EVAL.md)\\n- [Request a free Document Filters evaluation](https://www.hyland.com/en/resources/document-filters-version-evaluation)\\n\\n## Document Filters Resources\\n\\n- [Document Filters on GitHub](https://github.com/Hyland/DocumentFilters)\\n- [Document Filters on NuGet](https://www.nuget.org/packages/Hyland.DocumentFilters)\\n- [Document Filters Samples](https://github.com/Hyland/DocumentFilters/tree/master/samples)\\n  - [Compare Documents C#](https://github.com/Hyland/DocumentFilters/tree/master/samples/csharp/CompareDocuments)\\n  - [Compare Documents Python](https://github.com/Hyland/DocumentFilters/blob/master/samples/python/CompareDocuments.py)\\n- [Document Filters Documentation](https://docs.hyland.com/DocumentFilters/en_US/Print/index.html)\\n- [Document Filters Release Notes](https://docs.hyland.com/DocumentFilters/en_US/Print/release_notes/index.html)\\n- [Hyland](https://www.hyland.com/en/products/document-filters)"},{"id":"24.2-release","metadata":{"permalink":"/DocumentFilters/blog/24.2-release","source":"@site/blog/2024-05-15-24.2-release/index.md","title":"Document Filters 24.2 Release","description":"Explore the new features of Hyland Document Filters with the 24.2 release, ranging from document comparison to accessibility.","date":"2024-05-15T00:00:00.000Z","tags":[{"label":"Release","permalink":"/DocumentFilters/blog/tags/release"}],"readingTime":2.25,"hasTruncateMarker":true,"authors":[{"name":"Nabih Metri","title":"Document Filters Product Owner","imageURL":"https://github.com/nmetrihyland.png","key":"nabihmetri"}],"frontMatter":{"slug":"24.2-release","title":"Document Filters 24.2 Release","tags":["Release"],"authors":["nabihmetri"],"image":"./Thumbnail.png","description":"Explore the new features of Hyland Document Filters with the 24.2 release, ranging from document comparison to accessibility.","keywords":["text extraction","document conversion","document transformation","document filters","text extraction","document conversion","document transformation","blog","demo","walk through","release","document comparison","accessibility","OCR","AI"]},"unlisted":false,"prevItem":{"title":"Exploring the Document Comparison APIs","permalink":"/DocumentFilters/blog/comparison-api"},"nextItem":{"title":"Document Filters for AI Solutions","permalink":"/DocumentFilters/blog/df-for-ai-solutions"}},"content":"import Accessibility from \'./Accessibility.gif\'\\nimport GifPlayer from \'@site/src/components/GifPlayer\';\\nimport YouTubePlayer from \'@site/src/components/YouTubePlayer\';\\nimport ImgViewer from \'@site/src/components/ImgViewer\';\\n\\n\\nThe new 24.2 release of Hyland Document Filters introduces a range of features designed to streamline document comparison, improve accessibility, and integrate advanced OCR technology, with features being directly influenced by the Document Filters community. With these updates, Document Filters continues to evolve as a versatile tool that adapts to the diverse needs of its users.\\n\\n\x3c!-- truncate --\x3e\\n\\nWatch as we walk through a few of the new features in the 24.2 release of Document Filters.\\n\\n<YouTubePlayer src=\\"https://www.youtube.com/embed/-Nc111FEe5g?si=i4LE7tz5WU1ThrQd\\" alt=\\"Hyland Document Filters - 24.2 Features Preview Video\\" />\\n\\n## Document Comparison\\n\\nDocument Filters now includes a powerful feature for comparing text-based documents, such as PDFs and Microsoft Word documents. This new functionality allows users to quickly identify differences and changes, streamlining the review process, as well as reducing the cost needed to pass this comparison information to an AI solution. Read more about it in the [Document Filters documentation](https://docs.hyland.com/DocumentFilters/en_US/Print/common_use_cases/how_do_i_compare_documents.html).\\n\\n<ImgViewer src={require(\'./Document_Compare_Different_File_Formats.png\').default} alt=\\"Hyland Document Filters - Document Comparison - Different File Formats\\" />\\n\\nComparing a Microsoft Word document with a Text document, while ignoring the formatting differences and footers.\\n\\n<ImgViewer src={require(\'./Document_Compare_Different_Formatting.png\').default} alt=\\"Hyland Document Filters - Document Comparison - Different Formatting\\" />\\n\\nComparing the formatting of 2 Microsoft Word documents.\\n\\n## Accessibility Information Extraction\\n\\nIn order to extract every piece of information from documents, Document Filters has added the ability to extract accessibility information from Microsoft Office documents. Not only does this extract more information, but it also allows consumers to build applications that are fully accessible, ensuring that the end-users\' needs for accessible content are met. Explore how to extract this content in the [Document Filters documentation](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/about_accessibility_info_extraction.html).\\n\\n<GifPlayer src={Accessibility} alt=\\"Hyland Document Filters - Accessibility Information Extraction\\" />\\n\\n## Tesseract OCR Integration\\n\\nDocument Filters now supports seamless integration with any user-supplied version of the Tesseract OCR engine. This enhancement empowers consumers to leverage advanced OCR capabilities within their existing workflows, enhancing text recognition and extraction from images and scanned documents. Detailed instructions on how to utilize any version of the Tesseract OCR engine are available in the [Document Filters documentation](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/about_optical_character_recognition_ocr.html#using-a-different-version-of-tesseract).\\n\\n## File Type Categorization\\n\\nIn order to be able to identify the type of application that created a file, Document Filters has implemented a new file type categorization. Categories range from Text, to Spreadsheet, to Archive, with many more listed under the [IGR_FILETYPE_CATEGORY](https://docs.hyland.com/DocumentFilters/en_US/Print/techinfo_constants_and_codes/igr_filetype_category_type.html) type in the documentation.\\n\\n## Release Links\\n\\n- [Document Filters 24.2 Release Notes](https://docs.hyland.com/DocumentFilters/en_US/Print/release_notes/rel_24_2_0_0000.html)\\n- [Document Filters 24.2 Software Bill of Materials](https://github.com/Hyland/DocumentFilters/releases/download/v24.2/document-filters-24.2.0.5063-sbom.json)\\n- [Enhancement Requests](https://community.hyland.com/feedback)\\n\\n## Document Filters Resources\\n\\n- [Document Filters on GitHub](https://github.com/Hyland/DocumentFilters)\\n- [Document Filters on NuGet](https://www.nuget.org/packages/Hyland.DocumentFilters)\\n- [Document Filters Samples](https://github.com/Hyland/DocumentFilters/tree/master/samples)\\n- [Document Filters Documentation](https://docs.hyland.com/DocumentFilters/en_US/Print/index.html)\\n- [Document Filters Release Notes](https://docs.hyland.com/DocumentFilters/en_US/Print/release_notes/index.html)\\n- [Hyland](https://www.hyland.com/en/products/document-filters)"},{"id":"df-for-ai-solutions","metadata":{"permalink":"/DocumentFilters/blog/df-for-ai-solutions","source":"@site/blog/2024-05-14-df-for-ai-solutions/index.md","title":"Document Filters for AI Solutions","description":"Watch as we discuss using Hyland Document Filters for AI solutions. We\'ll go over the benefits, use cases, and current implementations of Document Filters in the AI field.","date":"2024-05-14T00:00:00.000Z","tags":[{"label":"AI","permalink":"/DocumentFilters/blog/tags/ai"}],"readingTime":1.605,"hasTruncateMarker":true,"authors":[{"name":"Nabih Metri","title":"Document Filters Product Owner","imageURL":"https://github.com/nmetrihyland.png","key":"nabihmetri"}],"frontMatter":{"slug":"df-for-ai-solutions","title":"Document Filters for AI Solutions","tags":["AI"],"authors":["nabihmetri"],"image":"./Thumbnail.png","description":"Watch as we discuss using Hyland Document Filters for AI solutions. We\'ll go over the benefits, use cases, and current implementations of Document Filters in the AI field.","keywords":["text extraction","document conversion","document transformation","document filters","AI","training models","model inference","federated learning","text extraction","document conversion","document transformation","blog","demo","walk through","use case"]},"unlisted":false,"prevItem":{"title":"Document Filters 24.2 Release","permalink":"/DocumentFilters/blog/24.2-release"},"nextItem":{"title":"Converting Documents with Comments","permalink":"/DocumentFilters/blog/convert-document-with-comments"}},"content":"import YouTubePlayer from \'@site/src/components/YouTubePlayer\';\\n\\n\\nIn the dynamic realm of AI development, Hyland\'s Document Filters is a game-changer, offering developers a versatile toolkit for file identification, content extraction, document transformation, and document conversion across over 600 file formats. Our presentation underscores its pivotal role in AI solutions, from enhancing data security with robust redaction features to streamlining operations, and to reducing costs. As AI companies integrate Document Filters into their enterprise offerings, it exemplifies the toolkit\'s potential to revolutionize AI applications, ensuring efficiency, security, and compliance in our data-driven future.\\n\\n\x3c!-- truncate --\x3e\\n\\nWatch as we walk through an overview of Hyland Document Filters and its benefits for AI solutions.\\n\\n<YouTubePlayer src=\\"https://www.youtube.com/embed/qCMSc2ztVzs?si=wHAgIcIGqecXKMY8\\" alt=\\"Hyland Document Filters - Document Filters for AI Solutions\\" />\\n\\n## Running the Document Filters Samples\\n\\nYou can try out various features using the [Document Filters sample apps](https://github.com/Hyland/DocumentFilters/tree/master/samples) on GitHub.\\n\\nTo get started with the Document Filters sample applications:\\n\\n1. Clone or download the [Document Filters sample repo](https://github.com/Hyland/DocumentFilters/tree/master) from GitHub.\\n2. Update the Document Filters license key by either modifying the `DocumentFiltersLicense` file or setting it in an environment variable named `DF_LICENSE_KEY`.\\n    - You can run the sample applications without a license key, with some limitations. See [Document Filters Evaluation](https://github.com/Hyland/DocumentFilters/blob/master/EVAL.md) for details.\\n4. Build `Document Filters Samples.sln` and run the `ConvertDocumentWithComments` app, while passing in an input document.\\n\\n## Add Document Filters to an Existing App\\n\\nOnce you\'re ready to integrate Document Filters into your application, you can follow these guides:\\n\\n- [Getting Started with .NET](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/create_a_net_api_c_and_vbnet_application.html)\\n- [Getting Started with Python](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/create_a_python_api_application.html)\\n- [Getting Started with Java](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/create_a_java_api_application.html)\\n- [Getting Started with C](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/create_a_c_api_native_library_functions_application.html)\\n- [Getting Started with C++](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/create_a_c_api_class_wrapper_around_native_library_functions_application.html)\\n- [Getting Started with COM](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/create_a_com_api_application.html)\\n\\n## Document Filters Evaluation\\n\\n- [Try a feature limited version of Document Filters](https://github.com/Hyland/DocumentFilters/blob/master/EVAL.md)\\n- [Request a free Document Filters evaluation](https://www.hyland.com/en/resources/document-filters-version-evaluation)\\n\\n## Document Filters Resources\\n\\n- [Document Filters on GitHub](https://github.com/Hyland/DocumentFilters)\\n- [Document Filters on NuGet](https://www.nuget.org/packages/Hyland.DocumentFilters)\\n- [Document Filters Samples](https://github.com/Hyland/DocumentFilters/tree/master/samples)\\n- [Document Filters Documentation](https://docs.hyland.com/DocumentFilters/en_US/Print/index.html)\\n- [Document Filters Release Notes](https://docs.hyland.com/DocumentFilters/en_US/Print/release_notes/index.html)\\n- [Hyland](https://www.hyland.com/en/products/document-filters)"},{"id":"convert-document-with-comments","metadata":{"permalink":"/DocumentFilters/blog/convert-document-with-comments","source":"@site/blog/2024-05-01-convert-document-with-comments/index.mdx","title":"Converting Documents with Comments","description":"Learn how to convert documents with comments using Hyland Document Filters. Preserve insights and feedback with our content processing Software Development Kit (SDK).","date":"2024-05-01T00:00:00.000Z","tags":[{"label":"Feature","permalink":"/DocumentFilters/blog/tags/feature"},{"label":"API","permalink":"/DocumentFilters/blog/tags/api"}],"readingTime":2.005,"hasTruncateMarker":true,"authors":[{"name":"Nabih Metri","title":"Document Filters Product Owner","imageURL":"https://github.com/nmetrihyland.png","key":"nabihmetri"}],"frontMatter":{"slug":"convert-document-with-comments","title":"Converting Documents with Comments","tags":["Feature","API"],"authors":["nabihmetri"],"description":"Learn how to convert documents with comments using Hyland Document Filters. Preserve insights and feedback with our content processing Software Development Kit (SDK).","keywords":["text extraction","document conversion","document transformation","document filters","text extraction","document conversion","document transformation","blog","demo","walk through","use case"]},"unlisted":false,"prevItem":{"title":"Document Filters for AI Solutions","permalink":"/DocumentFilters/blog/df-for-ai-solutions"},"nextItem":{"title":"Document Filters 24.1 Release","permalink":"/DocumentFilters/blog/24.1-release"}},"content":"import Document_Filters_PDF_Comments from \'./Document_Filters_PDF_Comments.gif\'\\nimport YouTubePlayer from \'@site/src/components/YouTubePlayer\';\\nimport GifPlayer from \'@site/src/components/GifPlayer\';\\n\\n\\n\\nIn software development, where every line of code counts, the Hyland Document Filters SDK is a beacon of efficiency for the document conversion process. This SDK is crafted to streamline the document conversion solution, ensuring that embedded comments\u2014the lifeblood of project collaboration, packed with critical feedback and key insights\u2014are not just preserved, but seamlessly integrated into the converted documents. It\u2019s a solution that resonates with the developer community, offering a way to enhance digital workflows with precision and ease. By incorporating this SDK, developers can confidently tackle the document conversion process, armed with the assurance that the collaborative essence of the documents remains intact, bolstering the robustness of their applications.\\n\\n\x3c!-- truncate --\x3e\\n\\nWatch as we walk through the code of how Hyland Document Filters can be used to convert a Word document to a PDF while preserving its comments.\\n\\n<YouTubePlayer src=\\"https://www.youtube.com/embed/MUAszQha67c?si=FndqZDgQJGT8JE_z\\" alt=\\"Hyland Document Filters - Converting Documents with Comments Video\\" />\\n\\n## Converting Documents with Comments\\n\\nExplore how Hyland Document Filters effortlessly transforms Word documents with comments into PDFs, preserving all comments for seamless information sharing.\\n\\n<GifPlayer src={Document_Filters_PDF_Comments} alt=\\"Hyland Document Filters - Converting Documents with Comments Demo\\" />\\n\\n## Running the Document Filters Samples\\n\\nYou can try out various features using the [Document Filters sample apps](https://github.com/Hyland/DocumentFilters/tree/master/samples) on GitHub.\\n\\nTo get started with the Document Filters sample applications:\\n\\n1. Clone or download the [Document Filters sample repo](https://github.com/Hyland/DocumentFilters/tree/master) from GitHub.\\n2. Update the Document Filters license key by either modifying the `DocumentFiltersLicense` file or setting it in an environment variable named `DF_LICENSE_KEY`.\\n    - You can run the sample applications without a license key, with some limitations. See [Document Filters Evaluation](https://github.com/Hyland/DocumentFilters/blob/master/EVAL.md) for details.\\n4. Build `Document Filters Samples.sln` and run the `ConvertDocumentWithComments` app, while passing in an input document.\\n\\n## Add Document Filters to an Existing App\\n\\nOnce you\'re ready to integrate Document Filters into your application, you can follow these guides:\\n\\n- [Getting Started with .NET](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/create_a_net_api_c_and_vbnet_application.html)\\n- [Getting Started with Python](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/create_a_python_api_application.html)\\n- [Getting Started with Java](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/create_a_java_api_application.html)\\n- [Getting Started with C](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/create_a_c_api_native_library_functions_application.html)\\n- [Getting Started with C++](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/create_a_c_api_class_wrapper_around_native_library_functions_application.html)\\n- [Getting Started with COM](https://docs.hyland.com/DocumentFilters/en_US/Print/getting_started_with_document_filters/create_a_com_api_application.html)\\n\\n## Document Filters Evaluation\\n\\n- [Try a feature limited version of Document Filters](https://github.com/Hyland/DocumentFilters/blob/master/EVAL.md)\\n- [Request a free Document Filters evaluation](https://www.hyland.com/en/resources/document-filters-version-evaluation)\\n\\n## Document Filters Resources\\n\\n- [Document Filters on GitHub](https://github.com/Hyland/DocumentFilters)\\n- [Document Filters on NuGet](https://www.nuget.org/packages/Hyland.DocumentFilters)\\n- [Document Filters Samples](https://github.com/Hyland/DocumentFilters/tree/master/samples)\\n- [Document Filters Documentation](https://docs.hyland.com/DocumentFilters/en_US/Print/index.html)\\n- [Document Filters Release Notes](https://docs.hyland.com/DocumentFilters/en_US/Print/release_notes/index.html)\\n- [Hyland](https://www.hyland.com/en/products/document-filters)"},{"id":"24.1-release","metadata":{"permalink":"/DocumentFilters/blog/24.1-release","source":"@site/blog/2024-02-21-24.1-release/index.mdx","title":"Document Filters 24.1 Release","description":"Document Filters 24.1.0 is now available for download!","date":"2024-02-21T00:00:00.000Z","tags":[{"label":"Release","permalink":"/DocumentFilters/blog/tags/release"}],"readingTime":2.54,"hasTruncateMarker":true,"authors":[{"name":"Nabih Metri","title":"Document Filters Product Owner","imageURL":"https://github.com/nmetrihyland.png","key":"nabihmetri"}],"frontMatter":{"slug":"24.1-release","title":"Document Filters 24.1 Release","tags":["Release"],"authors":["nabihmetri"],"image":"./Thumbnail.png"},"unlisted":false,"prevItem":{"title":"Converting Documents with Comments","permalink":"/DocumentFilters/blog/convert-document-with-comments"},"nextItem":{"title":"Extracting text from any file is harder than it looks. Extracting formatting is even harder.","permalink":"/DocumentFilters/blog/extracting-text-from-any-file-is-harder-than-it-looks"}},"content":"import olmdate from \'./OLMDategif.gif\'\\nimport pdfxfagif from \'./PDFXFAgif.gif\'\\nimport archivecomments from \'./ArchiveCommentsgif.gif\'\\nimport xlsexternal from \'./XLSWorkbookLinksgif.gif\'\\nimport YouTubePlayer from \'@site/src/components/YouTubePlayer\';\\nimport GifPlayer from \'@site/src/components/GifPlayer\';\\n\\n\\nDocument Filters 24.1.0 is now available for download!\\n\\n\x3c!-- truncate --\x3e\\n\\n## Features Demo\\n\\n<YouTubePlayer src=\\"https://www.youtube.com/embed/uo0X2wzVfD4?si=IUN-aQm7ldteUh6m\\" alt=\\"Hyland Document Filters - 24.1 Features Preview Video\\" />\\n\\n### HD Support for PDF XFA\\n\\nPDF XFA files are often used for interactive forms and dynamic documents in the\\ngovernment, education, and financial industries. Document Filters now allows for\\nrendering these files in high definition, adding to the 100+ file formats\\nsupported in HD.\\n\\n<GifPlayer src={pdfxfagif} alt=\\"PDF XFA\\" />\\n\\nPDF XFA files require the\\n[`PDF_XFA_ENABLED`](https://docs.hyland.com/DocumentFilters/en_US/Print/techinfo_processing_options.html)\\noption, with the default having it disabled.\\n\\n### Comment Extraction from Archive Formats\\n\\nDocument Filters always has a goal of being able to extract every piece of\\ninformation from files, and we\u2019ve now expanded that. It\u2019s now possible to\\nextract comments from archive files (ZIP, RAR) with Document Filters.\\n\\n<GifPlayer src={archivecomments} alt=\\"Archive Comments\\" /> \\n\\n### OLM Date Field\\n\\nDocument Filters now allows for choosing which OLM date field should be used as\\nthe main Date field in OLM files.\\n\\n<GifPlayer src={olmdate} alt=\\"OLM Date Field\\" /> \\n\\nThe\\n[`OLM_DATE_FIELD`](https://docs.hyland.com/DocumentFilters/en_US/Print/techinfo_processing_options.html)\\noption can be set to a comma separated list of fields that determines the search\\npriority for the OLM Date field. The default is an empty list, which results in\\nthe first field that\'s found being used for the field.\\n\\n### XLS External Workbook\\n\\nLinks to external workbooks in XLS files are now processed when extracting text.\\n\\n<GifPlayer src={xlsexternal} alt=\\"XLS External Workbook\\" /> \\n\\nWhen extracting text from an XLS file and the `EXCELMODE=text` and\\n`SHOWHIDDEN=on` options are set, the\\n[`SHOWHIDDEN_EXCEL_REFS`](https://docs.hyland.com/DocumentFilters/en_US/Print/techinfo_processing_options.html)\\noption can be enabled to extract links to external workbooks. This option is\\ndisabled by default.\\n\\n## Additional Information\\n\\nFind additional information on how to implement existing and new functionality,\\nas well as all current and previous release notes for Document Filters on our\\n[documentation\\nsite](https://docs.hyland.com/DocumentFilters/en_US/Print/index.html).\\n \\n## Links and Info\\n\\n### How to download through Community\\n\\nThe update can be downloaded here: Perceptive Software Downloads - Select\\n\\"Document Filters\\" from the Product drop-down list and then search for the\\npackage name. Note that we post separate packages for separate platforms, you\\nwill need to download the correct package(s) for your platform(s) such as\\n\\"Document Filters 24.1.0.4978 windows\\".\\n\\n### How to download through nuget.org\\n\\nFor projects that support nuget packages, it\'s possible to consume Document\\nFilters directly from nuget.org. The Document Filters package can be found\\n[here](https://www.nuget.org/packages/Hyland.DocumentFilters) on nuget.org.\\n\\n### How to download through github.com\\n\\nFor projects that do not support nuget packages, it\'s possible to consume\\nDocument Filters directly from github.com. The Document Filters binaries can be\\nfound [here](https://github.com/HylandSoftware/DocumentFilters) on github.com.\\n \\n### Documentation\\n\\nView our documentation at\\n[docs.hyland.com](https://docs.hyland.com/DocumentFilters/en_US/Print/index.html).\\n\\n### Sample Applications\\n\\nLearn how to use different Document Filters features through our sample\\napplications on\\n[GitHub](https://github.com/HylandSoftware/DocumentFilters/tree/master/samples).\\n\\n### Software Bill of Materials\\n\\nDownload the Software Bill of Materials for the release from\\n[here](https://community.hyland.com/en/gallery/items/-/media/74dfc7ea20c243119f5e081b5adf7b6b.json).\\n\\n### Release Notes\\n\\nView release notes from this release and previous releases\\n[here](https://docs.hyland.com/DocumentFilters/en_US/Print/release_notes/index.html).\\n\\n### Enhancement Requests\\n\\nSubmit Document Filters enhancement requests through\\n[Feedback](https://community.hyland.com/feedback) on Community."},{"id":"extracting-text-from-any-file-is-harder-than-it-looks","metadata":{"permalink":"/DocumentFilters/blog/extracting-text-from-any-file-is-harder-than-it-looks","source":"@site/blog/2021-10-04-extracting-text/index.md","title":"Extracting text from any file is harder than it looks. Extracting formatting is even harder.","description":"Backdrop","date":"2021-10-04T00:00:00.000Z","tags":[],"readingTime":12.685,"hasTruncateMarker":true,"authors":[{"name":"Ben Truscott","title":"Document Filters Principal Engineer","imageURL":"https://github.com/bentruscott.png","key":"bentruscott"},{"name":"Corey Kidd","title":"(Frm) Product Owner","key":"coreykidd"}],"frontMatter":{"slug":"extracting-text-from-any-file-is-harder-than-it-looks","title":"Extracting text from any file is harder than it looks. Extracting formatting is even harder.","tags":[],"authors":["bentruscott","coreykidd"],"image":"./Thumbnail.png"},"unlisted":false,"prevItem":{"title":"Document Filters 24.1 Release","permalink":"/DocumentFilters/blog/24.1-release"}},"content":"![Backdrop](Splash.png)\\n\\nThis post was originally hosted on the\\n[Stack\\nOverflow Blog](https://stackoverflow.blog/2021/10/04/extracting-text-from-any-file-is-harder-than-it-looks-extracting-formatting-is-even-harder/).\\n\\nWe take for granted document processing on an individual scale: double-click the\\nfile (or use a simple command-line phrase) and the contents of the file display.\\nBut it gets more complicated at scale. Imagine you\u2019re a recruiter searching\\nresumes for keywords or a paralegal looking for names in thousands of pages of\\ndiscovery documents. The formats, versions, and platforms that generated them\\ncould be wildly different. The challenge is even greater when it\u2019s time\\nsensitive, for example if you have to scan all outgoing emails for personally\\nidentifiable information (PII) leakages, or you have to give patients a single\\nfile that contains all of their disclosure agreements, scanned documents, and\\nMRI/X-ray/test reports, regardless of the original file format.\\n\\n\x3c!-- truncate --\x3e\\n\\nAt Hyland we produce a document processing toolkit that independent software\\nvendors can implement to identify files, extract text, render file content,\\nconvert formats, and annotate documents in over 550 formats. These are Document\\nFilters, and any software that interacts with documents will need Document\\nFilters.\\n\\nOne library for 550 formats may seem like overkill, but imagine stringing\\ntogether dozens of open source libraries, testing each of these libraries each\\ntime a new release hits the wild. We give you one dependency, one point of\\ncontact if something goes wrong, and one library to deploy instead of dozens.\\n\\nWe started as a company that sold desktop search software called ISYS. The\\napplication was built in Pascal for MS-DOS and provided mainframe-level search\\non PCs. Eventually, other companies, such as Microsoft and Google, started\\nproviding desktop search applications for free, and it\u2019s tough to compete with\\nfree.\\n\\nThis led us to realize that the sum of the parts was greater than the whole;\\ngetting text out of files and delivering the exact location is harder than it\\nseems and relevant to applications other than search. Our customers noticed our\\nstrength in text extraction and wanted that as something they could integrate or\\nembed in their software and across multiple platforms.\\n\\nIdentifying that Pascal was not going to meet our needs we pivoted our engineers\\nto rebuild the app in C++ over the next year for about half a dozen computing\\nplatforms. Since then, we\u2019ve learned a lot about content processing at scale and\\nhow to make it work on any platform.\\n\\n## On any platform\\n\\nWhen we rewrote our software, one of the key factors was platform support. At\\nthe time, Pascal only supported Windows, and while it now supports Mac and\\nLinux, it was and still is a niche language. That wasn\u2019t going to work for us,\\nas we wanted to support big backend processing servers like Solaris and HP-UX.\\nWe considered writing it in C, but we would have had to invent a lot of the\\nboilerplate that C++ gave us for free.\\n\\nWe were able to port about 80% of the code from Pascal. The other 20% was new OS\\nabstractions, primarily to support the Windows API functions we lose on other\\nplatforms and the various quirks of each platform. Each compiler makes different\\nassumptions of how to implement C++ code, so we use multiple compilers to see\\nwhat those assumptions are.\\n\\nComplicating things was that we not only had to consider operating systems, but\\nCPUs as well. Different CPUs process bytes in different orders, called byte\\nendianness. All Intel and ARM chips use little-endian, where the least\\nsignificant byte is stored first. SPARC chips historically used in Solaris\\nmachines used big-endian storage, where the most significant byte was stored\\nfirst. When you\u2019re reading from a file, you need to know what chipset produced\\nit, otherwise you could read things backwards. We make sure to abstract this\\naway so no one needs to figure out the originating chipset before processing a\\nfile.\\n\\nUltimately, the goal is to have the software run exactly the same on all 27\\nplatforms. Some of the solution to that problem is just writing everything as\\ngenerically as possible without special code for each platform. The other\\nsolution is testing. With the conversion to C++, we wrote a lot of new tests in\\norder to exercise as much code on all platforms. Today, we\u2019ve expanded those\\ntests and made error detection much more strict. Lots of files and formats pass\\nthrough during tests and they need to come through clean.\\n\\n## Search and extract text at scale\\n\\nThe first step to locating or extracting text from a file is finding out what\\nformat the file is in. If you are lucky to get a plaintext file, then that\u2019s an\\neasy one. Unfortunately, things are rarely easy. There aren\u2019t a lot of standards\\navailable for how files are structured; what exists may be incomplete or\\noutdated. Things have changed a lot over the years; Microsoft is actually at the\\nforefront for publishing standards. They publish standards for most of their\\nfile types these days, particularly the newer ones.\\n\\nMany file types can be identified by an initial set of four bytes. Once you have\\nthat, you can quickly parse the file. Older MS Office files all had the same\\nfour bytes, which presented complications, especially since so many files were\\nin one of the four Office formats. You had to do a little extra detective work.\\nNewer Office files all identify as ZIP files\u2014they are all compressed XML\u2014so once\\nyou extract the XML, you start applying known heuristics and following markers.\\nMost XML is self-describing, so those markers can be easy to follow. Others\\ndon\u2019t have much of a path at all.\\n\\nBinary file types are harder. Some of the work here is reverse engineering and\\nmaking sure you basically have enough files that are a representative sample\\nset. But once you know the pattern, then detecting the file is absolutely\\npredictable. We don\u2019t use any machine learning or AI techniques to identify\\nfiles because of this. The challenge is working out what the pattern is and what\\npattern a given file fits.\\n\\nIdentifying files is the very first thing that we do, so it has to be fast. One\\nslow detection can impact everything and take us from sub-milliseconds per\\ndocument to 15 milliseconds per document. When you\'re trying to crank through\\nforty-thousand documents in a minute, that\'s a lot.\\n\\nWe gain a lot of speed from specializing in text search and extraction as a pure\\nback-end system. Alternate methods have used something like LibreOffice to\\nprocess documents as a headless word processor. End-user applications have\\ngraphic elements and other features that you don\u2019t care about. In a high-traffic\\nenvironment, that could mean 50 copies of LibreOffice running as separate\\nprocesses across multiple machines, each eating up hundreds of MB. If that\\ncrashes it could bring down vital business processes with it. It\u2019s not uncommon\\nto see server farms running LibreOffice for conversions that could be replaced\\nwith a single back-end process such as Document Filters. That\u2019s before\\nconsidering the other workarounds to process all the other file types you might\\nneed such as spreadsheets, images, and PDFs.\\n\\nBy focusing on processing text at a high volume, we can help clients that need\\nto process emails, incoming and outgoing, looking for data loss and accidental\\nPII leakages. These products need to scan everything going in or out. We call it\\ndeep inspection. We cracked apart every level of an email that could have text.\\nZipping something and renaming the extension is not enough to try and trick it.\\nAttaching a PDF inside a Word document inside an Excel document is also not\\nenough. These are all files that contain text, and security needs to scan all of\\nit without delaying the send. We won\u2019t try to crack an encrypted file, but we\\ncan flag it for human review. All this is done so quickly that you won\u2019t notice\\na delay in the delivery of critical email.\\n\\nWe can process text so quickly because we built in C++ and run natively on the\\nhardware; targeting native binaries also gives us the greatest flexibility where\\nwe can be embedded in applications written in a wide variety of languages. On\\ntop of that, all that work identifying file formats pays off. When scanning a\\nfile, we load as little as possible into memory, just enough to identify the\\nformat. Then we move to processing, where we ignore any information we don\u2019t\\nneed to spot text\u2014we don\u2019t need to load Acrobat forms and crack that stuff\\napart. Plus we let you throw as much hardware at the problem as you have. Say\\nyou are running a POWER8 machine with 200 cores, you can run 400 threads and it\\nwon\'t break a sweat. You want a lot of memory if you\'re doing that amount of\\ndocuments in parallel.\\n\\n## Make it look good\\n\\nOur clients weren\u2019t content with just searching and extracting text; they also\\nwanted to display it in web browsers. Around 2009, people wanted to convert\\ndocuments to HTML. When extracting text, the software doesn\u2019t care about whether\\nsomething is bolded or paginated\u2014we just want the text.\\n\\nFortunately, all that work we did in understanding file types paid off here. We\\nknew how to spot text, the markers that indicated each type, but now we had to\\nunderstand the full file structure. Suddenly, bold, italics, tables, page\\nbreaks, and tabs vs. spaces become a lot more important. Our first iteration of\\nHTML rendering, now called Classic HTML, created an unpaginated free flowing\\nversion of the file with as much formatting as we could pull. If you\u2019ve ever\\nlooked at the HTML generated by MS Word, you know that creating HTML that\\naccurately reflects a document is complicated.\\n\\nThere\u2019s seven billion people on the planet and all of them create a Word\\ndocument differently. Even within Word or open source .docx editors like\\nOpenOffice, you move an element and suddenly the formatting disappears. We had\\nto test out all of the possible behaviors in the specifications, and still we\\nfigured out some bugs by trial and error.\\n\\nWe had one bug where Windows and Mac versions were producing different shades of\\nblue. It was consistent across Office documents\u2014PowerPoint and Excel documents\\nall showed the same two shades of blue. Sometimes it comes down to different\\nsystem defaults and fonts on different platforms. Sometimes the answer is\\ncompletely subjective as to what the definition of blue is or whether a line\\nwraps before or after a word. In cases like that, you have to pick one of the\\ncases to propagate; one of them is right, but it\u2019s hard to suss out exactly\\nwhich one. There\u2019s no absolutes.\\n\\nFile format specifications, typically published by the vendor, don\u2019t always help\\nhere either. We\u2019ve seen a property change, while the spec doesn\u2019t clarify how\\nthat affects the formatting of the document. Then, when testing a thousand page\\ndocument, we find a bug on page 342, and our collective hearts sink a little\\nbit. In cases like these, we know it\u2019s going to take a while to sort out what\u2019s\\ncausing it, then prove it over millions of iterations.\\n\\nFor all the trouble that Word documents give us, at least there\u2019s structure; you\\nknow a table is a table. PDFs have none of that. They are probably the hardest\\nto deal with because they focus on how a document is drawn on a screen.\\nTechnically, characters can be placed individually anywhere on a page, so\\ndetermining column breaks, tables, and other formatting features requires\\nlooking at their rendered position on a screen.\\n\\nPre-internet, everyone had to create everything themselves. They made their own\\nformats in the dark. Everyone wrote binaries differently. And PDFs, while they\\nare getting better, can always reveal a new bug, no matter how large a corpus of\\ntest data we have.\\n\\nOpen source software and an increased focus on accessibility concerns have\\nchanged formats a lot. PDFs have started including more formatting information\\nto accommodate screen readers. Open source software needs to understand file\\nformats, so more information is published and file producers have started making\\ntheir files easier to understand.\\n\\nThe next step after understanding document format was to be able to take these\\nfiles and produce paginated output that looks near-pixel perfect to the source\\napplication. All that information we learned about file formats, let us create\\nwhat we call Paginated HD Renditions. Paginated output means the output looks\\nsimilar to if you were to print the document. That\u2019s reading and extracting text\\nfrom 550 formats, and creating fully formatted and paginated HD Renditions for\\nover 100 formats. Combined with a full markup and annotation API that can create\\nnative annotations and export to one of over 20 formats.\\n\\nWe\u2019ve talked a lot about Word and PDF documents, because that\u2019s what most people\\nuse. But we also can read in exotic file formats, like MRI and CT scan files.\\nThis has a significant application in medical situations where you may want to\\nconcatenate them with other medical forms, then output a PDF complete with the\\ndoctor\u2019s annotations. Want to throw us multiple documents from different file\\nformats? Go ahead, we\u2019re not limited to 1:1 input to output, we will ingest the\\ndata, understand it, and return it as a single file type of your choice.\\n\\n## Don\u2019t forget security\\n\\nAs we moved our product from a desktop search application, we\u2019ve had to increase\\nour focus on security. If a consumer-grade product crashes it impacts a single\\nuser. But if an embedded piece of software crashes, it could take the rest of\\nthe program\u2014possibly the entire server\u2014down with it. These crashes and exploits\\ncould open them up for further mischief. Over the years, we did get hit with a\\nfew surprises and got burnt.\\n\\nWhat may be common today certainly wasn\u2019t in the early 2000s. Static analysis,\\nunit tests with high code coverage, compiler sanitizers, CVE scans, and\\nfuzz-testing are all must haves.\\n\\nWe process files of unknown origins and quality. These files might come from a\\nthird-party that doesn\u2019t strictly follow specifications, so they might be\\ncorrupt, or they might be maliciously crafted to trigger vulnerabilities.\\n\\nStrict adherence to coding and security best practices only gets you so far.\\nTesting, both active and passive, is a constantly running background task that\\nhelps us in our efforts to detect and gracefully handle the unexpected.\\n\\nEach release is verified with 100K+ files to ensure no regressions or\\nperformance degradations. Each nightly build runs over 40K unit tests.\\nFuzz-tests number in the 10s of millions. And of course, third-party libraries\\nare scanned for vulnerabilities nightly.\\n\\n## Conclusion\\n\\nWe\u2019ve lived and breathed file types for decades, and seen the complexities that\\ngo into simply finding and extracting text. Some of the largest software\\ncompanies in the world leverage Document Filters for their document processing\\nneeds, processing terabytes of information hourly. Our team of engineers is\\nalways monitoring new and changing file-types so consumers of Document Filters\\nare well prepared for the future.\\n\\nIf you\u2019re starting a new project, feel there\u2019s room for improvement with your\\ncurrent tools, or not wanting to worry about the complexities of document\\nprocessing, you can always learn more by checking out our code samples or\\nrequesting an evaluation at DocumentFilters.com."}]}}')}}]);